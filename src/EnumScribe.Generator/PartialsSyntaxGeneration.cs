using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using static EnumScribe.Generator.Consts;

namespace EnumScribe.Generator
{
    /// <summary>
    /// A hand-coded strategy to generate EnumScribe partials source text.
    /// </summary>
    internal static class PartialsSyntaxGeneration
    {
        /// <summary>
        /// Generates the partials source code using manual generation.
        /// </summary>
        /// <returns>The text of the partials file.</returns>
        internal static SourceText GeneratePartialsSource(List<TypeInfo> typeInfos, int indentWidth)
        {
            StringBuilder sb = new(capacity: 320);

            sb.Append(
@"// <autogenerated/>
#nullable enable
using ").Append(ExtensionsNamespace).AppendLine(@";
");

            // Reduce to base types (not nested), group by namespace
            var typesByNamespace = typeInfos
                .Where(x => x.ParentType is null && x.HasFullPartialLineage)
                .GroupBy(x => x.Namespace);

            foreach (var namespaceGroup in typesByNamespace)
            {
                var baseIndent = 0;

                if (namespaceGroup.Key != EnumScribeGenerator.GlobalNamespaceName)
                {
                    sb
                        .Append("namespace ")
                        .AppendLine(namespaceGroup.Key)
                        .Append('{');

                    baseIndent = 1;
                }

                foreach (var rootType in namespaceGroup)
                {
                    sb.AppendLine();
                    GenerateTypeText(sb, rootType, baseIndent, indentWidth);
                }

                if (namespaceGroup.Key != EnumScribeGenerator.GlobalNamespaceName)
                {
                    sb.AppendLine("}");
                }

                sb.AppendLine();
            }

            sb.Length -= Environment.NewLine.Length;

            sb.AppendLine(
"#nullable restore");

            return SourceText.From(sb.ToString(), Encoding.UTF8, SourceHashAlgorithm.Sha256);

            static void GenerateTypeText(StringBuilder sb, TypeInfo type, int typeBaseIndent, int indentWidth)
            {
                sb
                    .Append(' ', typeBaseIndent * indentWidth)
                    .Append("partial ")
                    .Append(type.Type.ToText())
                    .Append(' ')
                    .Append(type.Name)
                    .AppendLine(type.GenericSignature)
                    .Append(' ', typeBaseIndent * indentWidth)
                    .AppendLine("{");

                if (type.ShouldScribe)
                {
                    var methodIndent = typeBaseIndent + 1;

                    if (type.EnumTypeMembers is not null)
                    {
                        foreach (var member in type.EnumTypeMembers)
                        {
                            if (member.IsPartialMethod == false)
                            {
                                if (type.JsonIgnoreNewtonsoft)
                                {
                                    WriteMemberAttributeText(sb, JsonIgnoreNewtonsoftAttribute, methodIndent, indentWidth);
                                }
                                if (type.JsonIgnoreSystem)
                                {
                                    WriteMemberAttributeText(sb, JsonIgnoreSystemAttribute, methodIndent, indentWidth);
                                }
                            }

                            WriteMemberText(sb, type, member, methodIndent, indentWidth);
                        }
                    }

                    if (type.NestedTypes is not null)
                    {
                        sb.AppendLine();
                    }
                }

                if (type.NestedTypes is not null)
                {
                    foreach (var nestedType in type.NestedTypes)
                    {
                        GenerateTypeText(sb, nestedType, typeBaseIndent + 1, indentWidth);
                    }
                }

                sb.Append(' ', typeBaseIndent * indentWidth).AppendLine("}");
            }

            static string StaticText(bool isStatic) => isStatic ? "static " : string.Empty;

            static void WriteMemberAttributeText(StringBuilder sb, string attribute, int indent, int indentWidth)
            {
                sb
                    .Append(' ', indent * indentWidth)
                    .Append('[')
                    .Append(attribute)
                    .AppendLine("]");
            }

            static void WriteMemberText(StringBuilder sb, TypeInfo type, MemberInfo member, int indent, int indentWidth)
            {
                sb
                    .Append(' ', indent * indentWidth)
                    .Append(member.Accessibility.ToText())
                    .Append(' ')
                    .Append(StaticText(member.IsStatic))
                    .Append(member.IsPartialMethod ? "partial " : string.Empty)
                    .Append(member.IsNullable ? "string? " : "string ")
                    .Append(member.Name)
                    .Append(type.Suffix)
                    .Append(member.IsPartialMethod ? "() => " : " => ")
                    .Append(member.Name)
                    .AppendLine(member.IsNullable ? "?.DescriptionText();" : ".DescriptionText();");
            }
        }

    }
}
